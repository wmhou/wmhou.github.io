<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Chapter6.2 Connection和Iterator接口]]></title>
    <url>%2F2018%2F12%2F22%2FJavaSE%2FChapter6%20%E9%9B%86%E5%90%88%2F2%E3%80%81Connection%E5%92%8CIterator%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Connection接口是List、Set、Queue接口的父接口，Connection接口定义的一些操作结合元素的方法，它的子接口自然也可以使用…… 2、Connection和Iterator接口Collection接口：Connection接口是List、Set、Queue接口的父接口，Connection接口定义的一些操作结合元素的方法，它的子接口自然也可以使用，我们看一下Connection里面有些什么通用方法： 方法 描述 Boolean add(Object o) 向集合中添加一个对象的引用 Void clear() 删除集合中的所有对象，即不再持有这些对象的引用 Boolean contains(Object o) 判断在集合中是否持有特定对象的引用 Boolean isEmpty() 判断集合是否为空 Iterator iterator() 返回一个Iterator对象，可用它来遍历集合中的元素 Boolean remove(Object o) 从集合中删除一个对象的引用 Boolean retainAll(Collection&lt;?&gt; c) 保留集合中的指定内容 Int size() 返回集合中元素的数目 Object[] toArray() 返回一个数组，该数组包含集合中的所有元素 Boolean equals(Object o) 对象比较 Int hashCode() 返回hash码 这些方法来源与API文档，用时查阅即可，我们写一个小程序来演示一下这些方法： 123456789101112131415161718192021222324252627public class CollectionDemo &#123; public static void main(String[] args) &#123; Collection collection = new ArrayList(); collection.add("元素"); collection.add(3); System.out.println("collection集合中元素个数为：" + collection.size()); collection.remove(3); System.out.println("collection集合中元素个数为：" + collection.size()); System.out.println("collection集合中是否包含\"添加元素\"字符串：" + collection.contains("元素")); collection.add(5); System.out.println("collection集合中的元素是：" + collection); Collection collection1 = new HashSet(); collection1.add("HashSet元素"); collection1.addAll(collection); System.out.println("collection1集合中的元素是：" + collection1); collection1.clear(); System.out.println("collection1集合中的元素个数是：" + collection1.size()); &#125;&#125; 输出结果是： 123456collection集合中元素个数为：2collection集合中元素个数为：1collection集合中是否包含"添加元素"字符串：truecollection集合中的元素是：[元素, 5]collection1集合中的元素是：[HashSet元素, 5, 元素]collection1集合中的元素个数是：0 以上演示了Collection接口中定义的一些常用方法：有添加元素、删除元素、返回个数、清空等，当我们直接打印的时候，会输出[…, …, …]这样的数据结构，很显然是有重写了toString()方法，那么如果我们要遍历集合元素呢？ 1234567891011121314151617public class CollectionEach &#123; public static void main(String[] args) &#123; Collection computer = new ArrayList(); computer.add("Dell"); computer.add("ThinkPad"); computer.add("MacBook"); computer.add("Huawei"); // foreach循环遍历元素 for (Object str : computer) &#123; System.out.println(str); &#125; // lambda表达式foreach循环遍历元素 computer.forEach(obj -&gt; System.out.println(obj)); &#125;&#125; 以上两种遍历方式都可以输出Collection集合的所有元素，我们看到Collection中放入的元素默认都是Object类型，我们通常不会这样做，一般情况下都会使用泛型来约束集合中元素的类型。当然除了这种方法，我们还可以直接使用for循环，或者下面我们要说的另一个接口Iterator来进行迭代： Iterator接口：Iterator接口同样是集合框架中存在的接口，他是独立于Collection和Map的另一个接口，也叫迭代器，主要用于遍历集合元素，Iterator接口定义了四个方法，我们用一个小程序演示一下： 123456789101112131415// 使用Iterator迭代器遍历集合Iterator iterator = computer.iterator();// forEachRemaining方法：java8提供使用Lambda表达式遍历集合iterator.forEachRemaining(obj -&gt; System.out.println("迭代集合元素：" + obj));// hasNext:返回是否还有下一个元素的判断while (iterator.hasNext()) &#123; // next:返回集合中的下一个元素 System.out.println(iterator.next()); if (iterator.next().equals("MacBook")) &#123; // remove:删除上一次next方法返回的元素 iterator.remove(); &#125;&#125; Iterator接口的方法比较简单，它主要的用途就是遍历集合。 本节代码路径]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter6 集合</category>
      </categories>
      <tags>
        <tag>Connection</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter6.1 集合框架概述]]></title>
    <url>%2F2018%2F12%2F21%2FJavaSE%2FChapter6%20%E9%9B%86%E5%90%88%2F1%E3%80%81%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[在Java实际编程中，常常需要存放多个数据，我们可以用之前说的数组来保存多个对象，但是数组的长度是不可变化的，这就限制了它的使用场景，更为重要的是，数组不能使用key-value键值对的方式存储数据…… 1、集合框架概述在Java实际编程中，常常需要存放多个数据，我们可以用之前说的数组来保存多个对象，但是数组的长度是不可变化的，这就限制了它的使用场景，更为重要的是，数组不能使用key-value键值对的方式存储数据。为了解决这一些问题，才引入的集合的概念，集合主要用于存储其他数据，也被叫做容器类。还有一点不同于数组的特性是：数组可以用来存储基本类型和引用类型的数据，但是集合只能用来保存引用类型数据。 java的集合类主要由两个接口派生而出：Collection和Map，这二者是Java集合框架的根接口，他们又派生出了一些子接口和实现类，我们看一下继承树： 从上面的集合框架图可以看到，Java集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键值对映射。Collection接口又有3种子类型，List、Set和Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap等。 下面我们详细看一下这些集合类型。]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter6 集合</category>
      </categories>
      <tags>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter5.9 枚举]]></title>
    <url>%2F2018%2F12%2F20%2FJavaSE%2FChapter5%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F09%E3%80%81%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[枚举是在Java5中引入的新特性，主要用来表示一些固定且有限的类，比如季节、星期和一些特殊的状态等。假设有这样一个场景，我们实现一个购物车的功能，里面有一项内容是商品状态…… 9、枚举枚举示例枚举是在Java5中引入的新特性，主要用来表示一些固定且有限的类，比如季节、星期和一些特殊的状态等。假设有这样一个场景，我们实现一个购物车的功能，里面有一项内容是商品状态，想想我们网上购物的场景，商品的状态可以简单分为：已付款、未付款、已发货、未发货、已签收、未签收这样的状态，我们需要一些固定的状态码来定义这些状态，按照原来的写法，我们可以定义一个ProductStatus类或者接口，来表示状态： 12345678public class ProductStatus &#123; public static final int FINISH_PAY = 1; public static final int NOT_PAY = 2; public static final int FINISH_CONSIGNMENT = 3; public static final int NOT_CONSIGNMENT = 4; public static final int FINISI_RECIVE = 5; public static final int NOT_RECIVE = 6;&#125; 上面的实例中我们定义的6个int类型的常量，用来对应商品的状态，根据不同的状态我们需要实现不同的功能。很好用是不是，不过试想一下，我们在实现购物车功能的时候是不是需要来回查看商品状态对应的状态码，现在数量比较少还好说，有些项目中会定义一些类似的常量类或者接口，这样，我们每次使用都要去查看具体的常量是不是存在，是不是会引发出一些小问题？那么如果使用枚举呢？看一下： 1234public enum ProductStatusEnum &#123; FINISH_PAY, NOT_PAY, FINISH_CONSIGNMENT, NOT_CONSIGNMENT, FINISI_RECIVE, NOT_RECIVE&#125; 枚举使用enum关键字表示，定义的位置类似于class和interface，它也是一种特殊的类型，名称代码规范遵循类名定义规范，通常我们会在枚举名字后加Enum来进行更准确的表达。 上面的枚举，定义了商品的6个状态，多个值之间用逗号分割。而这些值的调用也很简单，直接用枚举名调用就可以，12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#### 枚举类型赋值继续从上面的例子来看，如果我们需要特定的索引来表示商品的状态，而且我们同时要做到用中文更清晰地表示状态的话，我们可以这样写：```javapublic enum ProductStatusHasValueEnum &#123; FINISH_PAY(&quot;已支付&quot;, 1), NOT_PAY(&quot;未支付&quot;, 2), FINISH_CONSIGNMENT(&quot;已发货&quot;, 3), NOT_CONSIGNMENT(&quot;未发货&quot;, 4), FINISI_RECIVE(&quot;已签收&quot;, 5), NOT_RECIVE(&quot;未签收&quot;, 6); private String status; private int index; ProductStatusHasValueEnum(String status, int index) &#123; this.status = status; this.index = index; &#125; public static String getStatus(int index) &#123; for (ProductStatusHasValueEnum status : ProductStatusHasValueEnum.values()) &#123; if (status.getIndex() == index) &#123; return status.getStatus(); &#125; &#125; return null; &#125; public String getStatus() &#123; return status; &#125; public void setStatus(String status) &#123; this.status = status; &#125; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index = index; &#125; public static void main(String[] args) &#123; int index = 2; String status = ProductStatusHasValueEnum.getStatus(index); System.out.println(&quot;index = &quot; + index + &quot;的商品状态是：&quot; + status); &#125;&#125; 在这个实例的main方法中，我们可以根据传入的索引值找到对应的商品状态，以上实例中我们为商品状态赋予了说明和索引值，并且添加了构造器、普通方法和getter/setter方法，是不是和一个类很相似，需要注意的是，当我们为枚举中的参数赋值的时候，需要手动加入构造方法，构造方法中的参数根据枚举参数传入的值来确定，实例中我们为参数赋予一个String和一个int类型的值，此时构造器中也要存在这样的值，试想一下，有构造器我们就可以实例化枚举的对象了，要正确使用这个构造器创建对象，就要实例化其中的参数。 但是枚举类型的构造器默认并没有写出，事实上枚举类的构造器是private的，枚举类型不能被实例化，我们一般也不会采用像上例中的写法，因为我们主要用到的是枚举最前面定义的枚举值。 这样，除了枚举开始的的状态和构造器这一部分，其余是不是和一个普通的java类完全一样了？但是区别还是很大的，我们知道每一个class都默认集成java.lang.Object类，但是枚举类不是的，它默认继承java.lang.Enum类，下面看一下Enum类的常见方法。 枚举的常见方法下面列举了枚举的常见方法： 继续使用上面的实例，看一下这些方法的使用： 1234567891011121314151617181920212223242526272829303132333435363738394041public enum ProductStatusEnum &#123; FINISH_PAY, NOT_PAY, FINISH_CONSIGNMENT, NOT_CONSIGNMENT, FINISI_RECIVE, NOT_RECIVE&#125;class ProductStatusEnumMethods&#123; public static void main(String[] args) &#123; // 创建枚举类数组 ProductStatusEnum[] status = new ProductStatusEnum[]&#123;ProductStatusEnum.FINISH_PAY, ProductStatusEnum.NOT_PAY, ProductStatusEnum.FINISH_CONSIGNMENT, ProductStatusEnum.NOT_CONSIGNMENT, ProductStatusEnum.FINISI_RECIVE, ProductStatusEnum.NOT_RECIVE&#125;; for (int i = 0; i &lt; status.length; i++)&#123; System.out.println("status[" + i + "].ordinal(): " + status[i].ordinal()); &#125; System.out.println("----------------------------------"); //通过compareTo方法比较,实际上其内部是通过ordinal()值比较的 System.out.println("status[0].compareTo(status[1]): " + status[0].compareTo(status[1])); System.out.println("status[0].compareTo(status[2]): " + status[0].equals(status[2])); Class&lt;?&gt; clazz = status[0].getDeclaringClass(); System.out.println("clazz: " + clazz); System.out.println("----------------------------------"); // name() System.out.println("status[0].name(): " + status[0].name()); System.out.println("status[1].name(): " + status[1].name()); //toString() System.out.println("status[2].toString(): " + status[2].toString()); System.out.println("status[3].toString(): " + status[3].toString()); System.out.println("----------------------------------"); ProductStatusEnum statusEnum = Enum.valueOf(ProductStatusEnum.class, status[4].name()); System.out.println("statusEnum：" + statusEnum); &#125;&#125; 实际执行结果是： 1234567891011121314151617status[0].ordinal(): 0status[1].ordinal(): 1status[2].ordinal(): 2status[3].ordinal(): 3status[4].ordinal(): 4status[5].ordinal(): 5----------------------------------status[0].compareTo(status[1]): -1status[0].compareTo(status[2]): falseclazz: class com.wmhou.chapter5.enumdemo.ProductStatusEnum----------------------------------status[0].name(): FINISH_PAYstatus[1].name(): NOT_PAYstatus[2].toString(): FINISH_CONSIGNMENTstatus[3].toString(): NOT_CONSIGNMENT----------------------------------statusEnum：FINISI_RECIVE 再说一下，使用枚举要注意几个地方，避免错误使用： enum 类型不支持 public 和 protected 修饰符的构造方法，因此构造函数一定要是 private 或 friendly 的。也正因为如此，所以枚举对象是无法在程序中通过直接调用其构造方法来初始化的。 定义 enum 类型时候，如果是简单类型，那么最后一个枚举值后不用跟任何一个符号；但如果有定制方法，那么最后一个枚举值与后面代码要用分号’;’隔开，不能用逗号或空格。 由于 enum 类型的值实际上是通过运行期构造出对象来表示的，所以在 cluster 环境下，每个虚拟机都会构造出一个同义的枚举对象。因而在做比较操作时候就需要注意，如果直接通过使用等号 ( ‘ == ’ ) 操作符，这些看似一样的枚举值一定不相等，因为这不是同一个对象实例。 上述部分列举了关于Enum的基本内容，这些内容基本可以满足日常开发中对枚举的使用，当然枚举的内容不会只有这些，更多的内容等以后用到再继续更新。Enum 类型提出给 JAVA 编程带了了极大的便利，让程序的控制更加的容易，也不容易出现错误。所以在遇到需要控制程序流程时候，可以多想想是否可以利用 enum 来实现。 本节代码路径]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter5 面向对象</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter5.8 Lambda表达式]]></title>
    <url>%2F2018%2F12%2F19%2FJavaSE%2FChapter5%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F08%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Lambda表达式是Java8的新特性，它支持将代码块作为参数进行传递，这个特性我们之前是没有接触过的，在Java中定义的方法不可能完全独立，也不能将方法作为参数或者返回一个方法，Lambda可以做到这一点…… 8、Lambda表达式Lambda表达式是Java8的新特性，它支持将代码块作为参数进行传递，这个特性我们之前是没有接触过的，在Java中定义的方法不可能完全独立，也不能将方法作为参数或者返回一个方法，Lambda可以做到这一点。 Lambda简介简单来说，Lambda表达式就是没有声明的方法，也就是说没有访问修饰符、返回值和名字。当某个方法只使用一次而且定义很简短，就不必在类中再去定义一个这样的方法了。 它的语法结构是（argument）-&gt;（body）语法书写，如下： 12(arg1, arg2, ...) -&gt; &#123;body&#125;(type1 arg1, type2 arg2, ...) -&gt; &#123;body&#125; Lambda表达式结构根据上面语法示例看一下Lambda表达式的结构： 一个表达式可以有0个或者多个参数； 参数类型可以明确声明，也可以根据上下文推断； 参数包含在小括号之内，相互之间用逗号分割； 只有一个参数且类型可以根据上下文得到时，小括号可以省略； 当表达式主体中只有一条语句，大括号可以省略，如果有多条，大括号必须存在。 Lambda表达式与函数式接口在Java中，函数式接口是只包含一个抽象方法声明的接口，例如run()```，如果要去实现这个接口，进而实例化对象，我们通常会使用implements的方式，此外还可以使用匿名内部类来实例化一个对象，而使用Lambda则更加简便，如下123456789101112131415161718192021222324252627```javapublic class LambdaDemoImpl implements Runnable&#123; @Override public void run() &#123; &#125; public static void test(Runnable runnable)&#123; runnable.run(); &#125; public static void main(String[] args) &#123; // 匿名内部类 test(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;Anonymous class&quot;); &#125; &#125;); // 使用Lambda表达式 test( () -&gt; System.out.println(&quot;Lambda expression&quot;)); &#125;&#125; 执行输出： 12Anonymous classLambda expression 上面的例子里，我们使用Runnable函数式接口并与 Lambda 表达式一起使用。test() 方法现在可以将 Lambda 表达式作为参数。多看几个例子： Lambda表达式举例线程初始化： 123456789101112//原有方法:new Thread(new Runnable() &#123;@Overridepublic void run() &#123; System.out.println("Hello thread");&#125;&#125;).start();//Lambda表达式:new Thread( () -&gt; System.out.println("Hello thread")).start(); 再看一个更神奇的例子： 1234567891011121314public static void main(String[] args) &#123; // 常规方法 List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 7, 9); for (Integer i: list) &#123; System.out.println(i); &#125; //Lambda表达式 list.forEach(i -&gt; System.out.println(i)); // ：：双冒号操作符将一个常规方法转化为Lambda表达式 list.forEach(System.out::println);&#125; 再来一个例子，从实例中学习才是最有效的 1234public interface LambdaInter&lt;T&gt; &#123; boolean exec (T t);&#125; 123456789101112131415161718192021222324public class LambdaDemo1 &#123; public static void test(List&lt;Integer&gt; list, LambdaInter&lt;Integer&gt; lambdaInter) &#123; for (Integer n : list) &#123; if (lambdaInter.exec(n)) &#123; System.out.print( n + " "); &#125; &#125; &#125; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7); System.out.print("打印所有数："); test(list, (n) -&gt; true); System.out.print("不打印："); test(list, (n) -&gt; false); System.out.print("偶数："); test(list, (n) -&gt; n % 2 == 0); &#125;&#125; 输出结果是： 123打印所有数：1 2 3 4 5 6 7 不打印：偶数：2 4 6 上面的实例中我们首先定义了一个函数式接口，提供一个返回boolean的方法，在一个普通的Java类中去使用这个接口，Lambda根据上下文得出参数类型，我们也可以自己定义一些代码逻辑去实现不同的功能。 Lambda在笔者经历的项目中，主要应用还是在Runable接口的使用中，其他方面并不是很多，而且，在有些团队中也不会允许使用Lambda表达式，有时候可能会影响代码可读性，但是Lambda作为Java8新特性，最起码要知道它的作用，读到相关的代码也不至于完全看不明白。 本节代码路径]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter5 面向对象</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter5.7 抽象类、接口和内部类]]></title>
    <url>%2F2018%2F12%2F18%2FJavaSE%2FChapter5%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F07%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[在前面的例子中，我们编写的每一个类都定义了相关的方法，这些方法都有具体的方法体来描述这个类的某种行为。但是在某些特殊情况下，某个父类只是确定子类应该包含哪些方法，却不知道子类的具体实现，就引入的抽象类…… 7、抽象类、接口和内部类在前面的例子中，我们编写的每一个类都定义了相关的方法，这些方法都有具体的方法体来描述这个类的某种行为。但是在某些特殊情况下，某个父类只是确定子类应该包含哪些方法，却不知道子类的具体实现，就引入的抽象类。举例来说，编写一个Shape类表示形状，这个类提供了计算面积和周长的两个方法，但是不同的子类例如圆、三角形、长方形的周长和面积的计算方式都不一样，要满足这样一个场景，就可以提供抽象方法，只有方法名，没有具体实现的方法。 抽象类抽象类就是用abstract关键字修饰的类，它是一种特殊的类，抽象方法同样也是用abstract修饰，看下实例： 12345678910111213141516public abstract class Shape &#123; public Shape() &#123; System.out.println("构造方法"); &#125; //计算周长 public abstract double calPerimeter(); //计算面积 public abstract double calArea(); public void color()&#123; System.out.println("打印颜色的普通方法"); &#125;&#125; 我们定义了一个Shape类，用abstract修饰，提供了构造器，并且提供了计算面积和周长的两个抽象方法，还有一个打印颜色的普通方法。抽象方法的定义中是不能包含{}的，就算没有方法体，下面定义一个类Circle继承Shape看一下用法： 12345678910111213141516171819202122232425262728293031323334public class Circle extends Shape &#123; private double r; public Circle(double r) &#123; this.r = r; &#125; public Circle() &#123; &#125; @Override public double calPerimeter() &#123; double perimeter = 2 * Math.PI * r; System.out.println("半径为" + r + "的圆周长 = " + perimeter); return perimeter; &#125; @Override public double calArea() &#123; double area = Math.PI * Math.pow(r, 2); System.out.println("半径为" + r + "的圆面积 = " + area); return area; &#125; public static void main(String[] args) &#123; Circle circle = new Circle(3); circle.calPerimeter(); circle.calArea(); Shape shape = new Circle(); shape.color(); &#125;&#125; 运行main方法后输出结果： 12345构造方法半径为3.0的圆周长 = 18.84955592153876半径为3.0的圆面积 = 28.274333882308138构造方法打印颜色的普通方法 Circle类很简单，定义了属性半径，并具体实现了Shape类中两个抽象方法，抽象类有自己的构造器但是不能用new去实例出一个对象，构造器主要用来被子类调用。一个抽象类有这样一些规则： 抽象类中可以拥有抽象方法和普通方法； 有抽象方法的类一定是抽象类； 抽象类不能像普通类一样用new关键字去创建实例，只能当做父类被继承。 多态很灵活很好用。 抽象类的用法总体来说是比较简单的，但是其中的思想可能会要在实践中才能体会，作为一个抽象类，在实际的项目中，应该是作为构架一级的存在，制定某些规则由子类去实现，就像一个公司的构架中，有老板，经理和员工，员工来执行事务，经理可以对事务进行管理，但是没必要具体去做，当然经理也有老板交代的事只能自己去完成，这里制定和管理事务就类似抽象方法、具体要做的事就是抽象类中的普通方法了，那么老板呢？假设一个老板主要是制定规则，所有的事都是手底下的人去完成，他不需要自己去做，那么，老板就是我们即将要拿出来的概念——接口。 接口不同于类定义，接口使用class，而是用interface关键字定义接口，但是接口的访问修饰符只有两种：public或者default（默认），接口名的定义遵循类名定义规则，接口名首字母大写，多个单词首字母都大写的驼峰式命名。从上面对抽象类的说明，我们知道接口也是一种规范，所以，接口中是不包含构造器和初始化块，一个接口中可以包含成员变量（只能是静态常量）、方法（抽象方法、类方法或默认方法）、内部类（内部接口、枚举）定义。 我们知道接口中定义的是多个类共同的行为规范，因此，接口中所有成员都应该是public访问权限。定义接口中的成员可以省略public，如果要指定，就只能是public访问控制修饰符。 12345678910public interface Boss &#123; int ID = 1; void setWork(String msg); static void eat (String food) &#123; System.out.println("午餐是：" + food); &#125;&#125; 上面实例的接口中，定义了成员变量、普通方法和类方法，成员变量的定义必须要赋予初始值，否则编译错误，我们知道final的变量都是要赋予初始值的，在接口中定义成员变量，默认使用public static final 修饰的，不写的话系统默认提供。下面一个普通方法，本质就是abstract修饰的一个抽象方法，所以没有方法体。此外还有一个static修饰的类方法，此方法可用使用接口名直接调用。事实上，在实际的项目中，接口中我们一般会定义一些相关类共同使用的常量由接口直接调用，和一些普通方法供实现类重写，很少在接口中写一个具体的方法，这与我们的初衷有悖。 说到接口是用来定义规则的，那么定义了规则就要有具体的类去实现，接口不同于类的继承，接口的复用我们称为实现，使用implements关键字，而且接口是可以多实现的，也就是说一个普通的类可以同时实现多个接口，而类继承只能是单继承，一个类同一时间只能继承一个父类。 123public interface Product extends Boss&#123; int getCount();&#125; 1234567891011public class TestImpl implements Boss, Product &#123; @Override public void setWork(String msg) &#123; &#125; @Override public int getCount() &#123; return 0; &#125;&#125; 总得来说要注意的点是： 类实现接口使用implements关键字，普通类继承父类、接口继承接口使用extends关键字； implements后面可以跟多个接口用“，”分割，extends后面只能继承一个类； 接口没有构造方法，不能被实例化，主要用来定义通用规则，要灵活使用多态创建对象。 接口中定义的方法默认使用public修饰，成员变量默认使用public static final修饰。 从这里我们也可以看出接口和抽象类最大的区别，当然接口的实际应用是很广的，后面还会大量用到。 内部类内部类，顾名思义就是定义在一个类内部的类，为什么要使用内部类呢？ 内部类在程序中实现了更深一层的封装，内部类可以访问外部类的私有数据，但是外部类不能访问内部类的实现细节； 内部类离开了当前外部类是没有任何意义的，只作用于当前类； 看一下内部类的主要分类，从其中体会作用： 非静态内部类： 前面我们说过静态和非静态，也就是static修饰符的作用，非静态内部类就是在类内部定义的普通类，如下： 1234567891011121314151617181920public class InnerClass &#123; private int id; private String name; public void test() &#123; ClassA classA = new ClassA(); classA.innerMethod(01, "内部类"); &#125; private class ClassA &#123; public void innerMethod(int id, String name) &#123; System.out.println(id + "_" + name); &#125; &#125; public static void main(String[] args) &#123; InnerClass innerClass = new InnerClass(); innerClass.test(); &#125;&#125; 可以看到，内部类的使用方法和普通类其实是一样的，需要注意的是，我们有时候会见到一个java文件中有多个类，但是它们都是独立存在的，这中写法不能叫做内部类，只有定义在一个类的范围之内才是。 上面的实例中，我们在一个public类中定义了一个private修饰的类，内部类作为一个成员，自然可以使用public、private、protected和static修饰，外部类是不可以的。此外需要注意的一个细节是：一个普通的java文件中，有且只有一个public修饰的类，且这个类名要作为文件名存在，这个规则是正确的，但要注意和内部类的概念区分开。 静态内部类 所谓静态，自然就是static修饰，这样的类叫做静态内部类。既然是static修饰的，它就属于当前类本身，而不是当前外部类的某一个对象。不同于普通的非静态内部类，静态内部类中是可以包含静态成员也可以包含非静态成员的。我们知道静态成员是不能访问非静态成员的，所以静态内部类不能访问外部类的实例成员，只能访问外部类的静态成员。至于说到类的访问修饰符，参照前面封装中说到的细节，大同小异。 123456789static class ClassB&#123; public static void staticInnerMethod()&#123; System.out.println("静态内部类"); &#125; public void staticInnerMethodB()&#123; // test(); //编译失败，静态内部类不能访问外部类普通方法 testForStatic(); &#125;&#125; 此外，接口中也可以定义内部类，且默认使用public static修饰，也就是说接口中定义的内部类只能是静态内部类。 局部内部类 这个局部内部类不同于前面说的两种类型，它是在方法中定义的内部类，因为这种内部类只作用于当前方法，所以局部内部类不能使用访问控制符和static修饰，实际开发中真没见过这种写法，此处略过。 匿名内部类 我们先以一个实例演示： 123456789101112131415161718192021public class NoneNameInnerClass &#123; public void test(Product product) &#123; product.getCount(); System.out.println("普通方法"); &#125; public static void main(String[] args) &#123; NoneNameInnerClass innerClass = new NoneNameInnerClass(); //匿名内部类 innerClass.test(new Product() &#123; @Override public void getCount() &#123; System.out.println("重写接口方法"); &#125; &#125;); &#125;&#125;interface Product &#123; void getCount();&#125; 匿名内部类的使用有规则制约; 创建匿名内部类时会立即创建对象，所以匿名内部类不能使抽象类； 匿名内部类必须继承一个父类或者实现一个接口，但最多也只能实现一个接口； 匿名内部类不能定义构造器，但是可以定义初始化块。 在实际开发中，内部类这一部分相对较少，其使用也是扩展自原有知识，写的不够清晰，后面用到再补回来。 本节代码路径_抽象类 本节代码路径_接口 本节代码路径_内部类]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter5 面向对象</category>
      </categories>
      <tags>
        <tag>抽象类</tag>
        <tag>接口</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter5.6 static和final修饰符]]></title>
    <url>%2F2018%2F12%2F17%2FJavaSE%2FChapter5%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F06%E3%80%81static%E5%92%8Cfinal%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[前面章节说到变量的时候，曾说到过一个概念：类变量，我们说用static修饰的变量就是类变量，那么说到static，还有什么作用呢？我们详细看一下，在引入static之前先看一个新概念…… 6、static和final修饰符static修饰符：前面章节说到变量的时候，曾说到过一个概念：类变量，我们说用static修饰的变量就是类变量，那么说到static，还有什么作用呢？我们详细看一下，在引入static之前先看一个新概念： 初始化块 java中我们使用构造器来对某个对象进行初始化操作，类似于构造器的另一个概念是初始化块，它也可以对Java对象进行初始化操作，看一下下面的实例 1234567891011121314151617public class Person &#123; &#123; System.out.println("------第一个初始化块------"); &#125; &#123; System.out.println("------第二个初始化块------"); &#125; public Person() &#123; System.out.println("---无参构造器---"); &#125; public static void main(String[] args) &#123; new Person(); &#125;&#125; 运行代码输出： 123------第一个初始化块------------第二个初始化块---------无参构造器--- 上面实例中，我们定义了一个类Person，并顺序创建了两个初始化块和一个无参构造器，初始化块的定义很简单，就是一对{…}，里面写上代码即可，main方法中我们只创建了一个Person对象，从运行结果可以看到，当创建一个对象的时候，JVM会先去执行类中定义的初始化块，如果定义了多个初始化块，则从上往下顺序执行。假如我们要创建多个对象，就会在每次创建对象前先去执行初始化块中的代码，改写一下main方法，我们再创建一个Person对象： 1234public static void main(String[] args) &#123; new Person(); new Person();&#125; 运行程序输出结果： 123456------第一个初始化块------------第二个初始化块---------无参构造器---------第一个初始化块------------第二个初始化块---------无参构造器--- 说明：初始化块在每次创建对象之前都会先执行，每创建一个对象，顺序执行一次。 初始化块也是类中的成员，但我们也看到，它没有名字也没有标识，自然不能被类或者对象调用，它只会在程序运行时被JVM自动执行。那么疑问来了，既然都可以初始化代码，它和构造器的区别是什么呢？ 从上面的实例看一下，初始化块是不能被调用且不能接受任何参数的，因此，不管有多少个重载的构造器，只要创建对象，都会先去执行初始化块，基于这个原因，我们可以把多个构造器中相同的、无须接收参数的代码提取到初始化块中定义，降低冗余。如果我们希望在类初始化的时候执行一些操作，而不是每次创建对象都去重复执行呢？此时就需要用static修饰块，称为静态初始化块。 静态初始化块 继续以上面的实例来说，在代码中加入两个static修饰的块，改变之后的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839package com.wmhou.chapter5.statictest;/** * Description:初始化块演示 * &lt;br/&gt;网站：&lt;a href="https://github.com/wmhou/java_blog"&gt;Java_blog on Github&lt;/a&gt; * &lt;br/&gt;Program Name: Java_blog * &lt;br/&gt;Date:2018-2-27 * * @author 侯伟民 * @version 1.0 */public class Person &#123; private int id; private String name; private String gender; private String address; &#123; System.out.println("------第一个初始化块------"); &#125; &#123; System.out.println("------第二个初始化块------"); &#125; static &#123; System.out.println("----第一个静态初始化块---"); &#125; static &#123; System.out.println("----第二个静态初始化块---"); &#125; public Person() &#123; System.out.println("---无参构造器---"); &#125; public static void main(String[] args) &#123; new Person(); new Person(); &#125;&#125; 运行程序输出结果为： 12345678----第一个静态初始化块-------第二个静态初始化块---------第一个初始化块------------第二个初始化块---------无参构造器---------第一个初始化块------------第二个初始化块---------无参构造器--- 从输出结果来看，static块在程序运行时先被执行，有多个static修饰则顺序执行，且优先于初始化块执行。也就是说static块不依赖于对象的初始化而是依赖于类初始化，static块是类相关的，属于类的静态成员，通常用于对类变量执行初始化处理。神奇的static，到底是什么呢？ static，意为静态、全局，static可以用来修饰属性、方法和初始化块，当我们给一个属性或者方法加上static修饰符后，就可以在不创建一个对象的情况下直接用类去引用。 静态变量：tatic修饰的变量称作静态变量。静态变量和一般的成员变量不同，一个类在加载到内存时，静态变量只初始化一次，也就是说所有对象的静态变量在内存中都只有一个存储位置，每个对象中的静态变量都指向内存中同一个地址，它是在所有的对象之间共享的数据。 静态方法：总体来说，static修饰后就是属于类，和任何对象无关，拿一个典型的例子，Java中的Math类来说，这个类作为一个数学工具类存在，定义了很多可以减少我们工作量的方法，如图 这只是小小一部分，试想一下假如这个类下面没有static修饰的方法，我们要使用任何一个方法都要先去new一个对象，如果要在不同方法中大量使用，是不是有点扯了，此时static就显现出作用了，不用创建对象，直接用类名调用，多好。可是偷懒的人们又发现了这样用会出现很多的Math.XXX()方法，是不是可以不用Math，static再次派上用场 静态导包： 这一种用法，把static方法加在了import之后，如下： 1import static java.lang.Math.*; 这样，就可以很愉快地去掉Math，直接使用Math类里面的方法了，不过，通常不建议这么玩； 此外，static方法中不能使用this和super？为什么呢，我们知道this和super代表当前类和父类的对象，但是我们的static可是全局的，虽然属于某个类，但实际上和当前类并没有直接关系，自然不能在这样的方法中直接访问某个类的变量和方法了。 final修饰符：final意为最终的意思。修饰符可以用来修饰类、方法和变量，统一来说，用final修饰的类、方法和变量都是不可改变的，详细看一下： final修饰类 当一个类用final修饰的时候，它是不能够被继承的，例如： 12public final class Super&#123; &#125; 12public class FinalTest extends Super&#123;&#125; 定义一个final修饰的父类Super，用另一个类去extends Super类，会编译错误： 意思是不能继承final修饰的类，final修饰的类中每个方法都应该是final的。 final修饰方法 final修饰符修饰方法的时候，该方法不能被重写，基于上面的例子进行修改，在父类Super中加入一个final修饰的方法，在子类中重写会编译错误： 12345public class Super &#123; public final void finalTest()&#123; System.out.println("final修饰的方法"); &#125;&#125; final修饰成员变量 final修饰的成员变量必须显式指定初始值，我们知道成员变量是随着类或对象的初始化而初始化的，所以不能先定义后赋值，看一下实例： 12private final String id; //这种写法，编译错误private final String name = "final"; final修饰局部变量 final修饰基本类型变量：此时需要对该final变量赋予初始值，且不能被重新赋值； 123456public void testFinal()&#123; final int i; i = 5; // i = 8; 在第一次被赋值之后，不能被重新赋值，否则编译错误； System.out.println(i);&#125; final修饰引用类型变量：此时final只会保证该final变量引用的地址不会改变，也就是说一直引用同一个对象，但是这个对象本身完全可以发生改变。 12345final int[] arr = &#123;2, 4, 6, 8&#125;;// arr = new int[]&#123;1, 3, 5, 7&#125;; 不能被重新赋值arr[0] = 1;arr[3] = 7;System.out.println(Arrays.toString(arr)); 输出结果是： 1[1, 4, 6, 7] 这个实例演示了，final修饰的引用数据类型，不能给赋值，但是可以改变对象内容的。 本节代码路径_static修饰符 本节代码路径_final修饰符]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter5 面向对象</category>
      </categories>
      <tags>
        <tag>static</tag>
        <tag>静态</tag>
        <tag>final</tag>
        <tag>私有</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter5.5 多态]]></title>
    <url>%2F2018%2F12%2F16%2FJavaSE%2FChapter5%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F05%E3%80%81%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态，面向对象语言的三大基本特征之一，多态是面向对象语言的重要特性之一，多态在Java中存在于继承之中，简单描述就是：父类引用指向子类对象。根据对多态的描述…… 5、多态多态是面向对象语言的重要特性之一，多态在Java中存在于继承之中，简单描述就是：父类引用指向子类对象。根据对多态的描述，我们写一个简单实例演示一下： 12345678910111213141516171819public class Person &#123; private String name; private int age; private String gender; public Person(String name, int age, String gender) &#123; this.name = name; this.age = age; this.gender = gender; &#125; public String info() &#123; return "姓名是：" + name + "；年龄是：" + age + "；性别是：" + gender; &#125; public void play() &#123; System.out.println("姓名是：" + name + "；年龄是：" + age + "；就是喜欢玩玩玩"); &#125;&#125; 1234567891011121314public class Hero extends Person &#123; public Hero(String name, int age, String gender) &#123; super(name, age, gender); &#125; @Override public String info() &#123; return "我是子类重写的方法"; &#125; public static void main(String[] args) &#123; Person p1 = new Hero("孙大圣", 5000, "男"); System.out.println(p1.info()); p1.play(); &#125;&#125; 运行main方法输出结果是： 12我是子类重写的方法姓名是：孙大圣；年龄是：5000；就是喜欢玩玩玩 首先我们看到，通常情况我们初始化一个类如Hero的时候，会使用Hero hero = new Hero()这样的方式，现在却使用了Person p = new Hero()的形式，让父类的引用去指向子类对象，同时我们在子类中重写了父类的info()方法，发现调用的时候执行了子类方法，如果没有重写，则会去调用父类中的方法。而如果定义一个Person类型的变量，让它指向一个new Person()的类型，此时只会执行父类中的方法。 在Java语言中，引用变量有两种类型：编译时类型和运行时类型，编译时类型由声明该变量时使用类型决定，运行时类型由实际赋给该变量的类型决定，在上面的实例中，变量p1的编译时类型为父类Person，运行时类型为子类Hero，由此可见，编译时类型和运行时类型的不一致，就可能出现多态现象。 总结一下，多态现象的必要条件： 继承或者实现； 方法重写； 父类引用指向子类对象。 本节代码路径]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter5 面向对象</category>
      </categories>
      <tags>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter5.4 继承]]></title>
    <url>%2F2018%2F12%2F15%2FJavaSE%2FChapter5%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F04%E3%80%81%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承，面向对象语言的三大基本特征之一，实现软件复用的重要操作，通过extends关键字实现，例如猫类继承动物类，苹果类继承水果类，实现继承的类叫做子类，被继承的类叫做父类或者基类…… 4、继承继承继承，面向对象语言的三大基本特征，实现软件复用的重要操作，通过extends关键字实现，例如猫类继承动物类，苹果类继承水果类，实现继承的类叫做子类，被继承的类叫做父类或者基类。举例： 1234567public class Birds&#123; private String color; public void view(String color)&#123; System.out.println("color："+ color); &#125;&#125; 12345678public class Ostrich extends Birds&#123; public static void main(String[] args) &#123; Ostrich ostrich = new Ostrich(); ostrich.view("黑色"); &#125;&#125; 上面的实例中我们先写了一个Birds作为父类，定义了一个属性color，一个view方法打印颜色，用一个Ostrich类继承Birds，Ostrich类就拥有了父类的方法，创建Ostrich对象就可以调用父类的方法，但是Ostrich对象并不能直接访问父类的私有属性，上面程序输出： 1color：黑色 可是，为什么要用继承呢？这样的方法自己写了不是更好？ 在上面的实例中，鸟类涵盖范围太大了，从麻雀到老鹰，从候鸟到留鸟，大部分的鸟类都会飞，但是飞的行为却不一样，所有的鸟类都要吃东西，但是有的食草有的食肉，还有各种各样的颜色。如果每一种鸟都去定义这样的方法，势必对出现大量重复的代码，所以才将共性的部分提取出来作为父类，事实上很多的继承并不是一开始就这么制定了，而是在优化的过程中不断抽取重复代码才出现的。 继承主要有以下特性： 子类拥有父类非private的方法和属性； 子类可以拥有自己独立的方法和属性，也就是子类的可扩展性； 子类可以重写父类的方法； java中的继承是单继承，也就是说一个父类可以有多个子类，但是一个子类只能继承于一个父类，如果我们要实现多重继承，就可以构造多个类，类A继承类B，类B继承类C。 方法重写：上面的例子中，鸵鸟类集成了鸟类，有了显示颜色的方法，鸟类会飞翔，但是鸵鸟并不会飞翔，所以鸵鸟要去重写飞翔的方法实现自己的逻辑，修改如下： 12345678910111213public class Birds&#123; private String color; public void view(String color)&#123; System.out.println("color："+ color); &#125; public void fly()&#123; System.out.println("鸟儿会飞。。。"); &#125;&#125; 1234567891011121314public class Ostrich extends Birds&#123; @Override public void fly() &#123; System.out.println("鸵鸟会跑不会飞。。。"); &#125; public static void main(String[] args) &#123; Ostrich ostrich = new Ostrich(); ostrich.view("黑色"); ostrich.fly(); &#125;&#125; 上面的例子中，如果子类没有重写fly方法，那么Ostrich的对象调用fly方法就会打印：鸟儿会飞，显然是不合逻辑的，而重写了这个方法之后，再去调用fly方法就是自己的实现了，打印出：鸵鸟会跑不会飞。一般我们会在重写的方法上一行写上@override标签来表示这是一个重写的方法，需要注意重写和重载的不同之处。 super关键字和构造方法调用：super关键字和this关键字很相似，不过super指向的是父类的对象，this指向的是当前类的对象，同样的super也不能出现在static修饰的方法中，实例如下： 12345@Override public void fly() &#123; super.view("鸵鸟颜色白加黑"); System.out.println("鸵鸟会跑不会飞。。。"); &#125; 在fly方法中使用super调用的是父类的方法，super表示父类的对象。这里使用的super实际上是调用了父类无参的构造器，而且在默认情况下也是调用父类无参的构造器。但如果我们想用super去调用父类声明的有参构造方法呢？ 重新写一个实例，我们知道构造方法是用来初始化一个对象的，来看一下子类是怎么执行父类的构造方法： 12345678910111213141516public class Employee &#123; private String id; private String name; private String department; public Employee() &#123; System.out.println("父类无参的构造方法"); &#125; public Employee(String id, String name, String department) &#123; this.id = id; this.name = name; this.department = department; System.out.println("父类有参的构造方法"); &#125;&#125; 1234567891011121314151617181920212223public class Manager extends Employee &#123; private double reward; public Manager() &#123; this(2000); &#125; public Manager(double reward) &#123; this.reward = reward; &#125; public Manager(String id, String name, String department, double reward) &#123; super(id, name, department); this.reward = reward; &#125; public static void main(String[] args) &#123; Manager managerA = new Manager(); Manager managerB = new Manager(20000); Manager managerC = new Manager("0002", "赵子龙", "集成工具部", 30000); &#125;&#125; 看一下这两个类，父类是雇员类，子类是经理类，这里同样也可以再说明一下什么时候使用继承，我们在处理两个对象时，如果有“is-a”的关系，就可以使用继承，比如上面的实例中，经理作为公司管理人员，在项目结束时会拿到奖金，而普通员工并没有，但同时经理也隶属于公司，同样作为雇员存在，所以可以用继承减少相同代码，去进行自己功能的扩展，同样作为雇员，人事、行政、技术、销售等各个岗位都会有自己的特性，各个岗位又有共性，此时就可以用继承来实现。 继续说到构造方法，上面的实例中，运行main()方法会输出如下结果： 123父类无参的构造方法父类无参的构造方法父类有参的构造方法 我们对子类构造了三个不同的对象，分别使用子类无参、有参构造器和super调用父类构造器，可以看到，不管是否使用super关键字，每一个对象的创建都会先去调用父类中的构造方法一次，总结一下： 如果子类构造器既没有super也没有this，则默认执行子类构造器前先执行父类无参构造器； 如果子类构造器使用this调用子类另一个重载的构造器，系统会根据传入的实参去掉用对应的构造器，执行该构造器之前又会先去调用父类无参构造器； 如果子类构造器第一行使用super调用父类构造器，系统会根据实参调用对应的父类构造器。 需要注意的是：this和super对构造器的调用都在代码第一行，所以它们不能同时出现。 Object类在前面的例子中，我们构造的普通java类中有重写toString、hashCode和equals方法，然而我们并没有使用extends关键字去集成任何一个类，那么怎么会有这些重写的方法呢？原因很简单，Java中定义了一个Object类，这个类是所有类的超类，也就是说每一个类都是由它扩展而来，默认每一个类都继承这个类，但是并不需要显式指定。结合前面构造方法的调用，我们初始化一个子类会先去调用父类的构造方法，Object类就是最顶层的父类。既然是作为最顶级的父类，那就一定提供了一些所有类通用的方法，下面看几个常用的方法： equals()方法：用来判断两个对象的内容是否相同，还记得前面说比较运算符说到的==吗，==在引用数据类型中比较的是对象的引用。先看一段代码，再讨论一下这二者之间的区别： 123456789101112public class EqualTest &#123; private int id; public EqualTest(int id) &#123; this.id = id; &#125; public static void main(String[] args) &#123; EqualTest e1 = new EqualTest(1); EqualTest e2 = new EqualTest(1); System.out.println(e1.equals(e2)); System.out.println(e1 == e2); &#125;&#125; 这个实例的输出结果是： 12falsefalse 很奇怪是不是，对于”==”运算符比较两个EqualsTest对象返回false，我们明白这点，因为e1和e2分别指向不同的对象，所以二者内存地址是不相同的。但是equals()方法呢？我们前面说比较的是内容，也就是说上例中拥有相同id的情况下我们认为两个对象是相等的，却返回了false。原因就是我们使用equals方法的时候没有去重写，所以此时调用的是Object类的equals()方法，这个原始方法内部的实现其实就是”==”，，看一下源码： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 所以，为了达到我们的期望值，就要重写equals()方法，让对象之间的比较按照我们需要的逻辑去比较内容，而不是内存地址，重写如下： 12345678@Overridepublic boolean equals(Object o) &#123; if (o instanceof EqualTest) &#123; EqualTest test = (EqualTest) o; return this.id == test.id; &#125; return false;&#125; 再次运行，我们发现输出的结果就满足我们的预期了： 12truefalse 上面重写的方法中用到了instanceof关键字，它可以用来判断某对象所指向的类型，判断返回boolean值，在上面的例子中传入的对象是EqualsTest类型，然后去比较id，也就是内容，返回比较的结果。 hashCode()方法： 一般要求在重写equals()方法的同时也重写hashCode()方法，该方法返回一个对象的哈希值，后面再说。 toString()方法： 该方法主要用来返回当前对象的字符串表达式，继续在上面的例子中重写如下： 1234@Overridepublic String toString() &#123; return "EqualTest&#123;" + "id=" + id + "&#125;";&#125; 打印该对象输出： 1EqualTest&#123;id=1&#125; 如果不去重写toString()方法，那么打印对象会输出如下结果（类名+@+hashCode）： 1com.wmhou.chapter5.extendstest.EqualTest@1540e19d 线程同步相关方法： wait()、notify()、notifyAll()方法，这几个方法在后面章节线程中会详细说明。 getClass()方法： 该方法会返回一个对象的类对象，关于这个方法会在后面章节反射机制中说明。​ 本节代码路径 下篇——Chapter5：05、多态]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter5 面向对象</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter5.3 封装]]></title>
    <url>%2F2018%2F12%2F14%2FJavaSE%2FChapter5%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F03%E3%80%81%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[封装是面向对象语言的三大特征之一，另外还有继承和多态，封装是指：将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法操作和访问类内部信息…… 3、封装基本概念：封装是面向对象语言的三大特征之一，另外还有继承和多态，封装是指：将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法操作和访问类内部信息。为什么要使用封装呢？因为我们经常会使用对象访问某个成员变量，如果第一次访问时给了值，第二次访问时又可能去改变属性的值，这样在语法上是不会有问题的，但是有悖于现实，所以使用封装，隐藏细节，而提供了方法访问。 具体实现封装就要用到访问控制符来实现。 访问控制符：Java中提供了四种访问控制权限，分别用private、default、protected和public表示，这四个访问控制符权限由小到大： private：修饰属性、构造方法和方法，权限是当前类； default：修饰属性、构造方法和方法，权限是同包内，可以不加任何访问控制符默认default修饰； protected：修饰属性、构造方法和方法，权限是子类，如果使用protected修饰，通常是希望子类重写该方法； public：修饰类、属性、构造方法和方法，最高权限，不论是否在同一个包内。 下面实例我们创建两个类，AccessControl类中定义了两个private的属性，定义了public的getter和setter方法，在AccessControlTest类中创建对象，访问某个属性，我们发现private的属性，在不同类中是没法直接访问的，只能访问public的方法，这样就隐藏了类的细节，实现了封装。由此看来，Java类中实例变量的getter和setter方法就有了很重要的意义，在当前类之外，只能通过getter和setter方法操作属性。 12345678910111213141516171819202122public class AccessControl &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 123456789public class AccessControlTest &#123; public static void main(String[] args) &#123; AccessControl control = new AccessControl(); control.setName("name测试"); String name = control.getName(); System.out.println("name：" + name); &#125;&#125; 输出结果： 1name：name测试 说到这里，还要说一下Java中程序涉及的原则：高内聚、低耦合。 高内聚：尽可能把模块内部数据、实现细节等隐藏，不允许外部程序直接干预； 低耦合：暴露少量的方法给外部使用。 关于访问控制符，有这样一些原则： 类中大部分成员变量都应该是private修饰，除非是一些static修饰的变量才有可能用public修饰，类内部使用的方法也使用private修饰； 如果某个类主要作为父类，希望子类重写方法而不是给外部使用，应该用protected修饰； 给外部其他类使用的方法由public修饰，所以一般用public修饰构造方法，除非是单例模式，设计模式后面会说。 package和import：前面多次说到包这个概念，那么什么是包呢？ 先看一下我们这个项目结构 src源码目录下，创建了com.wmhou包，在这个包下面又创建了多个chapter来存放不同章节的代码示例，我们把具有类似功能的多个类放在一个包下，包的概念在windows目录结构中其实就是一层层文件夹。实际开发中我们包名定义一般遵循Oracle公司的写法，域名+公司+项目（+子模块）的形式，一般来说我们会在一个类的首行写明这个类所属的包，如下： 12345package com.wmhou.chapter5.accesscontrol;public class AccessControl &#123;&#125; 那么当前类的类名其实就是：com.huawei.chapter4.AccessControl，如果我们需要在其他的包内引用这个类，就要使用import关键字引包，假如说我们要使用chapter4这个包下的ArrayTest这个类，写法如下： 1import com.wmhou.chapter4.ArrayTest; import写在一个类的package和class之间，如果有javadoc注释的话，写在注释后面，类名之前，当然，如果不用import的话就要写上类的全名，当然，一般不这么写，这么写的情况是，不同两个包内有两个相同的类名，而且参数相同，要使用这两个类的时候，某一个类就要加上全名才能区分。 1com.wmhou.chapter4.ArrayTest test = new com.wmhou.chapter4.ArrayTest(); Java中常用的包：Java按照不同功能提供了很多种开发人员常用的包，许多常用类就在这些包下，这些类也就是前面说过的API（应用程序接口），列举一些上用的包： java.lang：核心类，包含了String、System等常用类，这个包不需要import引入，可以直接使用； java.util：这个包包含一些常用工具类，例如Arrays等； java.net：提供网络编程相关接口和类，如Socket等； java.io：提供输入输出相关操作的接口和类，如ImputStream等； java.sql：提供JDBC数据库编程相关的接口和类。 本节代码路径]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter5 面向对象</category>
      </categories>
      <tags>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter5.2 方法]]></title>
    <url>%2F2018%2F12%2F13%2FJavaSE%2FChapter5%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F02%E3%80%81%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在前面的内容中我们一直有用到过方法，比如main()方法、输出打印的out()方法，那么到底什么是方法呢？在Java中，方法的定义是：包含于类或对象中的用于执行某种特定功能的代码…… 2、方法在前面的内容中我们一直有用到过方法，比如main()方法、输出打印的out()方法，那么到底什么是方法呢？ 在Java中，方法的定义是：包含于类或对象中的用于执行某种特定功能的代码，方法不能独立定义，只能在类中，由类或者所属类的对象调用执行。我们之前说过static修饰的方法可以用类名直接调用，当然也可以用这个类的对象调用，如果参数相同还是可以得到相同的执行结果，如果没有static修饰，就只能由对象调用。 命名规则：方法的命名不同于类，一般我们使用首字母小写后面单词以大写字母开头的形式，例如：addStudent； 方法定义和重载：前面我们已经定义过方法，知道一个方法的基本组成是：访问修饰符（可选）、返回值类型、方法名、形参和方法体这些基本元素构成，那么如何使用呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MethodTest &#123; //属性：id int id; //属性：name String name; //有参构造方法 public MethodTest(int id, String name) &#123; this.id = id; this.name = name; &#125; //无参构造方法 public MethodTest() &#123; &#125; //方法1：没有形参 public void exec() &#123; System.out.println("没有形参的方法：id = " + id + "; name = " + name); &#125; //方法2：有形参 public void exec(int id, String name) &#123; System.out.println("有形参的方法：id = " + id + "; name = " + name); &#125; //方法3：形参为引用类型 public void exec(MethodTest test) &#123; System.out.println("形参为对象的方法：id = " + test.id + "; name = " + test.name); &#125; //方法4：有返回值方法 public String exec(String name) &#123; System.out.println("有返回值的方法：name = " + name); return "SUCCESS"; &#125; //主方法，程序入口 public static void main(String[] args) &#123; MethodTest test1 = new MethodTest(2, "方法2"); test1.exec(); MethodTest test2 = new MethodTest(); test2.exec(1, "方法1"); test1.exec(test1); test1.exec(test2); test2.exec(test1); test2.exec(test2); String str1 = test1.exec("方法4"); System.out.println(str1); String str2 = test2.exec("方法4"); System.out.println(str2); &#125;&#125; 看下这个实例： 定义了id和name两个属性； 定义了有参和无参两个构造方法，构造方法名称和类名相同，叫做构造方法重载； 定义了4个方法，方法名都是exec，分别为没有形参、有形参、形参为引用数据类型和一个有返回值的方法，这里叫做方法重载，对于重载方法而言，也就是在同一个类中，方法名相同，形参列表不同（类型、数量、顺序不同）的多个方法,，通过传入对应的参数执行对应的方法； 定义了main()方法，也就是主方法、程序入口，创建了两个对象，去调用方法，执行得到如下结果： 12345678910没有形参的方法：id = 2; name = 方法有形参的方法：id = 1; name = 方法形参为对象的方法：id = 2; name = 方法形参为对象的方法：id = 0; name = null形参为对象的方法：id = 2; name = 方法形参为对象的方法：id = 0; name = null有返回值的方法：name = 方法SUCCESS有返回值的方法：name = 方法SUCCESS 参数传递：上面的实例中我们看到，方法是不能独立存在的，必须要在类中定义，如果要调用方法则需要类或者对象调用，如果方法包含了形参，那么调用这个方法的时候就需要给对应的形参传入指定参数值，这个参数值也被叫做实参。在Java中，参数传递只有一种：值传递。也就是说在参数传递的时候，实际传入的是实参的副本，不管方法内对传入的参数如何操作，都不会改变参数本身。 上面的代码中，方法内的形参有基本数据类型和引用数据类型，说明方法的参数传递，不仅可以传入基本数据类型，也可以传入引用数据类型，基本数据类型我们之前说过，这一类型的定义和值都是存储在栈区，而引用数据类型的值是存储在堆内存中，通过引用使用，类似与结构化编程语言中的指针，通过上面的例子看一下需要注意的地方： 使用方法必要要有类或者对象调用； 根据调用方法指定的形参列表传入具体的参数值来使用重载方法； 无返回值的方法直接使用，有返回值的方法需要指定对应返回值类型的变量接收返回参数 重点看一下类类型传递，不管使用哪个对象调用方法，都需要传入实参才能使用方法，如果没有具体值，就会使用类型本身的默认值，引用类型默认值为null。 形参个数可变的方法：Java中还有一个功能，就是允许定义形参个数可变的参数，使用时可以接收多个参数值，看一下这个实例： 123456789public class MethodTest &#123; public void exec(int id, String... name) &#123; System.out.println("有返回值的方法：id = " + id + " name = " + Arrays.toString(name)); &#125; public static void main(String[] args) &#123; MethodTest test2 = new MethodTest(); test2.exec(3, new String[]&#123;"参数1", "参数2", "参数3"&#125;); test2.exec(3, "参数1", "参数2", "参数3"); &#125; 输出结果是一样的： 1有返回值的方法：id = 3 name = [参数1, 参数2, 参数3] 形参个数可变方法，形参定义的时候在参数类型和变量名之间加…，使用的时候可以传入多个该类型的参数，实际上参数是以数组的形式存在，需要注意的是： 数组形式的参数可以位于形参列表内任意位置，个数可变的参数只能位于列表最后； 一个方法中有且只有一个个数可变的形参。 本节代码路径]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter5 面向对象</category>
      </categories>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter5.1 类和对象]]></title>
    <url>%2F2018%2F12%2F12%2FJavaSE%2FChapter5%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F01%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[在Chapter1.1、Java语言概述中大概介绍过Java作为面向对象语言的一些基本特征，现在详细说一下这两个重要概念：类（class）和对象（object）…… 1、类和对象在Chapter1.1、Java语言概述中大概介绍过Java作为面向对象语言的一些基本特征，现在详细说一下这两个重要概念：类（class）和对象（object）： 类：类，是Java语言中最基本的单位，类可以作为某一批对象的抽象，大了说有人类、鸟类、电脑类、编程语言类，他们都会有各自独有的属性去描述这一类事物，比如说人类可以有姓名、年龄、籍贯等更多更细致的属性，因为这些属性的不同，可以具象出一个个独立的对象，而这些属性中，或许有一部分可以拿来描述别的类，但是有些属性却是某些类所不具备的，比如描述人类的血型属性，我们不会拿来描述一只鸟或者一台电脑，同样电脑这个类的CPU、内存等属性也不会用来描述一个人或者人类，这样就有了一个个不同的类。 对于一个类而言，在Java中通常包含三种最常见的成员：成员变量、构造器和方法： 成员变量：也就是这个类需要的属性，Java中有一个很重要的概念叫抽象，也就是说我们在定义一个类的时候，不需要列举出所有的属性，而且也很难做到，我们只需要关注我们需要的属性就可以； 构造器：创建一个对象的根本途径，我们可以通过不同的构造器创建不同的对象，没有构造器是不能创建对象的，Java中提供了一种默认无参数的构造器，即使不显式写出也可以用来创建对象； 方法：也就是行为，我们可以为一个类定义不同的方法去做不同的事。 看一下我们应该如何定义一个类： 12345678910111213141516171819202122232425262728293031323334public class Students &#123; //属性：学号 private int studentId; //属性：姓名 private String name; //属性：年龄 private int age; //属性：籍贯 private String address; //属性：专业 private String subject; //属性：爱好 private String hobbies; //有参构造器 public Students(int studentId, String name, String subject) &#123; this.studentId = studentId; this.name = name; this.subject = subject; &#125; //无参构造器 public Students() &#123; &#125; public void study(int studentId, String name, String subject) &#123; System.out.println("学号：" + studentId + "；姓名：" + name + "专业：" + subject + ""); &#125;&#125; 上面的实例中我们定义了一个students的类，用来描述学生，学生有学号、姓名等属性，然后定义了一个有参构造器和一个无参构造器来创建对象，最后定义了一个学习的方法来描述学生行为，看一下语法： 类：访问修饰符 + class + 类名{}，类名首字母大写，多个单词组成每个首字母大写； 属性：数据类型 + 变量名； 构造器：访问修饰符 + 类名（参数1，…，参数n）{} 方法：访问修饰符 + 返回值 + 方法名（参数，…，参数n）{} 如果没有创建任何构造器，也可以通过new关键字创建一个默认对象，如果创建了有参构造器还要使用无参构造器创建对象，就一定要显式写出无参构造器。 对象：定义了类之后，我们就可以使用对象了，前面说过，创建一个对象需要构造器，Java中使用new关键字 + 构造器的形式来创建一个对象（实例）。 1234567891011121314public static void main(String[] args) &#123; //无参构造器 Students studentA = new Students(); //有参构造器 Students studentB = new Students(199108, "Da_师兄","软件工程"); //一个引用多个对象 studentA = studentB; //多个引用一个对象：studentC和studentD都指向同一个对象 Students studentC = studentA; Students studentD = studentA;&#125; 上面实例中我们分别使用无参和有参构造器创建了两个对象，然后用两个Students类型的变量去引用这两个对象，这样studentA和studentB就代表了两个不同的对象，不同于之前说过的基本数据类型，这里的对象属于引用数据类型，在内存中的存储是堆栈存储的，引用是存储在栈内存中，而具体的对象是存储在堆内存中。 假如说有多个引用要使用一个对象的时候，不会去复制这些对象，之需要引用这一个实际对象即可，以免造成资源浪费，而如果是一个引用多个对象的话，第一个对象就没有被引用了，换句话说，一个引用同一时间只能指向一个对象。 this引用在Java中，this关键字代表当前类的对象， 上面的例子中，在构造器中我们使用的this访问属性，下面看一下访问别的方法： 1234public void play(int studentId, String name, String hobbies) &#123; this.study(studentId, name, hobbies); System.out.println("学号：" + studentId + "；姓名：" + name + "专业：" + hobbies + "");&#125; 上面这个片段中，如果某个对象要使用play方法时，会先调用study方法，再执行打印，当然如果省略了this的话也可以执行，这个this依旧是存在的。需要注意的是，在static修饰的方法中是不能使用this的，因为static修饰的方法可以用类直接调用，如果方法内再用了this，这时候this就不能指向合适的对象，在静态方法中使用this会引起编译错误。 本节代码路径]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter5 面向对象</category>
      </categories>
      <tags>
        <tag>类</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter4.1 数组]]></title>
    <url>%2F2018%2F12%2F11%2FJavaSE%2FChapter4%20%E6%95%B0%E7%BB%84%2F1%E3%80%81%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组在Java中是一种常见的数据结构，用于存放相同类型的数据，并可以根据索引取出对应的元素的值…… 1、数组数组在Java中是一种常见的数据结构，用于存放相同类型的数据，并可以根据索引取出对应的元素的值，首先看一下如何定义一个数组： 定义数组：12int[] arr1;int arr2[]; //不推荐使用这种定义方式 定义一个数组有上述两种方式，不过通常都是用第一种方式，可读性更好。 数组初始化：数组必须进行初始化才可以使用，数组的初始化分为静态初始化和动态初始化两种： 123456//静态初始化int[] intArr1 = new int[]&#123;1, 3, 5, 7, 9&#125;;String[] strArr = &#123;"java", "数组"&#125;; //动态初始化int[] intArr2 = new int[5];intArr2[0] = 1; 静态初始化是在初始化数组时显式指定初始值，由系统决定长度； 动态初始化是在初始化数组时只指定数组长度，然后再为数组指定初始值； 不能同时使用两种初始化，即不能既指定数组长度又分配初始值； 数组的长度是不可变的，一旦分配好内存空间，就不能再变化。 数组使用：数组最常使用就是访问数组元素，数组每一个元素对应一个索引，索引值是从0开始，数组最后一个元素的索引等于数组的长度减1，如果使用数组时指定的索引值小于0或者大于数组长度，就会引发运行异常：数组下标越界。看一下这个例子： 12345int[] intArr1 = new int[]&#123;1, 3, 5, 7, 9&#125;;System.out.println("数组intArr1" + "的长度是：" + intArr1.length);for (int i = 0; i &lt; intArr1.length; i++)&#123; System.out.println("索引为："+ i + "的元素的值是：" + intArr1[i]);&#125; 运行结果是： 123456数组intArr1的长度是：5索引为：0的元素的值是：1索引为：1的元素的值是：3索引为：2的元素的值是：5索引为：3的元素的值是：7索引为：4的元素的值是：9 上面实例使用for循环取出了数组intArr1的所有元素，可以看到，数组的长度是5，索引最大值是4，每一个索引都对应数组中一个元素，如果使用foreach取出这个数组中的元素，写法就更简单： 1234for (int arr: intArr1) &#123; System.out.println("数组intArr1的元素的值是：" + arr); &#125; 使用循环为数组赋值： 使用动态初始化之后，如果我们需要为数组赋值，可以根据索引逐个赋值，也可以使用for循环，看一下这个实例： 123456789101112//动态初始化 String[] str = new String[5];//循环赋值for (int i = 0; i &lt; str.length; i++)&#123; str[i] = "我是数组" + i;&#125;//取值for (String str1: str)&#123; System.out.println("数组str的元素的值是：" + str1);&#125; 输出结果是： 12345数组str的元素的值是：我是数组0数组str的元素的值是：我是数组1数组str的元素的值是：我是数组2数组str的元素的值是：我是数组3数组str的元素的值是：我是数组4 需要注意的是：如果使用循环为数组赋值，我们不采用foreach，因为使用foreach只是将值赋予临时变量，并没有改变数组中实际存在的值，使用foreach赋值很容易引起错误，而且没有什么实际意义。 数组查找： 假设我们需要在一个很大的数组内找出其中的最大值，我们应该怎么做呢？ 123456789101112131415public static void main(String[] args) &#123; int[] arr = &#123;72, 6, 3, 9, 23, 66, 43, 66, 25, 21, 68, 67, 70&#125;; //查找最大值并打印 int max = arr[0]; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; System.out.println("数组arr的最大值是：" + max);&#125; 运行上面程序得到结果，最大值是72，原理很简单，设置一个变量，可以是数组中任意一个元素，然后用数组中每一个元素和它比较，如果数组中元素大于这个值，就把大的值赋给它，如果小于，则进行下一次循环，直到遍历完整个数组，查找最小值也是如此。 数组排序： 12345678910111213//冒泡排序for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125;&#125;for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + " ");&#125; 输出结果：3 6 9 21 23 25 43 66 66 66 68 70 72 常见的排序还有选择排序、插入排序，归并等，不再一一列举。 增强工具类Arrays：Arrays是针对数组的一个工具，包含了一系列static修饰的方法，也就是类方法，可以用类名直接访问，进行查找、排序和复制等操作，可以提高开发效率，实例如下： 123456789101112131415161718192021222324public static void main(String[] args) &#123; //定义数组1 int[] arr1 = new int[]&#123;1, 3, 5, 7, 9&#125;; //定义数组2 int[] arr2 = new int[]&#123;6, 4, 8, 2&#125;; System.out.println("数组是否相等：" + Arrays.equals(arr1,arr2)); //使用Arrays.binarySearch前需要对数组排序，否则结果会不准确 System.out.println("排序后：查看对应元素的索引：" + Arrays.binarySearch(arr1, 7)); System.out.println("排序前：查看对应元素的索引：" + Arrays.binarySearch(arr2, 2)); //定义数组3进行复制操作 int[] arr3 = Arrays.copyOfRange(arr1, 2, 4); System.out.println("转化为字符串：" + Arrays.toString(arr3)); //排序 Arrays.sort(arr2); System.out.println("数组arr2排序之后：" + Arrays.toString(arr2)); //填充 Arrays.fill(arr3, 9); System.out.println("数组arr2排序之后：" + Arrays.toString(arr3));&#125; 输出结果是： 123456数组是否相等：false排序后：查看对应元素的索引：3排序前：查看对应元素的索引：-1转化为字符串：[5, 7]数组arr2排序之后：[2, 4, 6, 8]数组arr2排序之后：[9, 9] Arrays还有很多用法，可以参考API使用。 二维数组：顾名思义，二维数组就是在一个数组中存储了多个数组的结构，如下： 12345678910111213int[][] arr = new int[2][1];arr[0] = new int[]&#123;1,3,5&#125;;arr[1] = new int[]&#123;2,4,6,8&#125;;for (int[] a: arr)&#123; System.out.println(Arrays.toString(a));&#125;int[][] arr1 = new int[][]&#123;&#123;1,3,5&#125;, &#123;2,4,6&#125;, &#123;7,8,9&#125;&#125;;for (int[] a: arr1)&#123; System.out.println(Arrays.toString(a));&#125; 输出结果： 12345[1, 3, 5][2, 4, 6, 8][1, 3, 5][2, 4, 6][7, 8, 9] 对比普通数组来说，普通数组是在数组中存储单个的值，而二维数组是将多个数组按照索引存放在一个数组中，在内存分配上，多维数组在内存中相当于分配了一个矩阵的存储空间。 本节代码路径]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter4 数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter3.3 循环结构]]></title>
    <url>%2F2018%2F12%2F10%2FJavaSE%2FChapter3%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F3%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[循环结构是实际项目中经常用到的流程控制结构，主要用来控制在满足循环条件的情况下反复执行某一段代码，这一段代码叫做循环体…… 3、循环结构循环结构是实际项目中经常用到的流程控制结构，主要用来控制在满足循环条件的情况下反复执行某一段代码，这一段代码叫做循环体，常用的循环结构有以下几种： for循环； 增强for循环：foreach； while循环； do…while循环； for循环：先来一个最简单的示例感受一下： 1234567public static void main(String[] args)&#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println("这是第" + i + "次循环"); &#125;&#125; 输出结果是： 12345这是第0次循环这是第1次循环这是第2次循环这是第3次循环这是第4次循环 看上去很复杂，其实并没有，先看一下for循环的语法： int i = 0，为for循环赋予初始值； i &lt; 5，循环条件； i++，自增，给变量i赋值； {循环体，如果只有一行可以省略大括号，一般不这么做} for循环表达式中的分号是不能缺少的 分析一下输出结果： 首先对变量i的值进行判断，发现满足条件&lt;5，直接执行循环体； 执行完循环体，进行i++运算，再次判断变量值，此时，i = 1满足条件&lt;5，执行循环体； 以上循环执行到i=5的时候，不满足循环，退出循环； 综上，我们可以看到for循环的执行顺序：初始化——判断条件——执行循环体——计算——判断条件，初始化的代码在循环中只执行一次。 升级一下复杂度，正好复习一下++的用法： 1234for (int i = 0; i &lt;= 5; i++) &#123; System.out.println("这是第" + i++ + "次循环"); &#125; 分析一下代码： 首先，i = 0，判断 i &lt;= 5，执行循环体打印，并进行 i++ 运算 ，执行打印：0； 对变量再次运算时，此时变量值已经是1，i++，判断时变量值2&lt;=5满足条件，执行打印：2； 对变量再次运算时，此时变量值已经是3，i++，判断时变量值4&lt;=5满足条件，执行打印：4； 再次运算时，此时变量值已经是3，i++，判断时变量值6&lt;=5不满足条件，退出循环。 实际输出的结果是： 123这是第0次循环这是第2次循环这是第4次循环 foreach——增强for循环：foreach是java5的新特性之一，在遍历数组、集合方面给开发者提供了很大的便利，下面的实例我们从一个最简单的数组说明一下foreach的语法结构： 123456789public static void main(String[] args)&#123; int[] ints = &#123;1,3,5,7,9&#125;; //for (类型 变量： 遍历对象) for(int i: ints) &#123; System.out.println(i); &#125;&#125; 输出结果是：1，3，5，7，9； 如果用改用for循环来写的话，就是这个样子，关于数组，后面还会进行深入分析。 1234for (int i = 0; i &lt; ints.length; i++)&#123; System.out.println(ints[i]);&#125; while循环：while循环的语法很简单，继续用一个实例说明： 123456789public static void main(String[] args) &#123; int i = 0; while (i &lt; 5) &#123; System.out.println("这是第" + i + "次循环"); i++; &#125; &#125; 输出结果： 12345这是第0次循环这是第1次循环这是第2次循环这是第3次循环这是第4次循环 需要注意的是：while循环一定要有保证循环条件变成false的时候，否则将会成为死循环，上例中如果没有i++控制，就会不停打印耗尽电脑性能。 do…while()循环：do while循环与while循环的区别在于：while循环是先判断条件，如果满足条件再执行循环体，而do while循环则是先执行循环体再去判断循环条件，如果满足条件则再次循环，不满足则中止，如下： 12345int j = 0; do &#123; System.out.println("这是第" + j + "次循环"); j++; &#125;while(j &lt; 5); 这段程序执行结果和while循环执行结果完全一致，可以看出，在do while循环中，无论是否满足条件，都至少会执行1次循环体，而while循环只要不满足则一次都不执行。 嵌套循环：升级难度了，上面我们执行的都是单个循环，但是在实际项目中嵌套循环也常会用到，上述4种循环都可以自由嵌套，先看一个实例，分析一下嵌套循环中代码的执行顺序； 123456789101112public static void main(String[] args)&#123; //外层循环 for (int i = 0; i &lt; 2; i++) &#123; //内层循环 for (int j = 0; j &lt; 3; j++) &#123; System.out.println("i的值为：" + i + "；j的值为：" + j); &#125; &#125;&#125; 分析一下： 首先执行外层循环，满足条件，进入循环体，执行内层循环，满足条件得到：i = 0， j = 0； 内层结束，计算变量j，判断&lt;3满足条件，继续执行打印：i = 0， j = 1； 再次计算，变量j = 2，满足条件&lt;3，打印结果：i = 0， j = 2； 再次计算，变量j = 3，不满足条件结束循环进如外层，此时，对变量i进行计算得到，判断i = 1 &lt; 2满足条件，执行循环体，重新执行内层循环，打印结果：i = 1，j = 0； 此时重复上述步骤，直到内层循环不满足条件退出，此时外层循环判断后也不满足条件，退出全部循环。 输出结果： 123456i的值为：0；j的值为：0i的值为：0；j的值为：1i的值为：0；j的值为：2i的值为：1；j的值为：0i的值为：1；j的值为：1i的值为：1；j的值为：2 由此可见，当发生嵌套循环时，如果满足外层循环条件则执行内层，此时内层循环体需要反复执行直到结束再进入外层循环，只有当外层循环不满足条件时才能真正退出嵌套循环，这样我们就可以得到嵌套循环执行总次数：如果外层执行m次，内层执行n次，那么总共会执行m*n次。 循环控制：说了这么多循环，怎么更好更主动地控制循环呢？比如说我们有一个循环，要在满足某一个条件时进行某个操作，此时我们就可以用到循环控制了，java中主要使用的循环控制有break、continue和return关键字 break break用于完全结束一个循环，跳出循环体，拿上面嵌套循环举例： 12345678for (int i = 0; i &lt; 2; i++)&#123; for (int j = 0; j &lt; 3; j++) &#123; System.out.println("i的值为：" + i + "；j的值为：" + j); break; &#125;&#125; 首先执行外层循环，满足条件进入循环体，执行内层循环，进入内层循环体，打印i = 0， j = 0，执行break退出内层循环进入外层，再次执行，打印i = 1， j = 0，退出内层，此时外层循环也不满足，退出全部循环； continue 不同于break，continue用于结束本次循环,，不再执行后面代码，再开始下一次循环，而不是完全结束一个循环，如下： 12345678for (int i = 0; i &lt; 3; i++)&#123; if (i == 1) &#123; continue; &#125; System.out.println("这是第" + i + "次循环！");&#125; 输出结果： 12这是第0次循环！这是第2次循环！ 可以看出，当变量值为1的时候，结束了当前循环，所以没有打印值为1的循环，如果是break的话，则在满足条件的时候会完全退出循环。 return return不止用于循环中，单独使用return可以结束一个方法，比如在嵌套循环中遇到了return，不过有多少层嵌套都会完全退出所有的循环，实例如下： 12345678for (int i = 0; i &lt; 2; i++)&#123; for (int j = 0; j &lt; 3; j++) &#123; System.out.println("i的值为：" + i + "；j的值为：" + j); return; &#125;&#125; 上面实例，只会输出i = 0， j = 0的结果，因为在执行完第一次打印之后碰到了return，便直接结束了所有的循环，在方法中关于return的使用还会说明。 本节代码路径]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter3 流程控制</category>
      </categories>
      <tags>
        <tag>循环结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter3.2 分支控制]]></title>
    <url>%2F2018%2F12%2F09%2FJavaSE%2FChapter3%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F2%E3%80%81%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Java流程控制之分支结构——if、switch…… 2、分支结构if分支语句if条件语句有以下三种形式： 1234567891011121314151617181920212223242526272829303132//if结构int score1 = 70;if (score1 &gt;= 60)&#123; System.out.println("成绩：" + score1 + "分，恭喜你，及格了...");&#125;//if...else...结构int score2 = 40;if (score2 &gt;= 60)&#123; System.out.println("成绩：" + score2 + "分，恭喜你，及格了...");&#125;else&#123; System.out.println("成绩：" + score2 + "分，没及格啊骚年...");&#125;//if...else if...else...结构int score3 = 76;if (score3 &lt; 60) &#123; System.out.println("成绩：" + score3 + "分，没及格啊骚年...");&#125; else if (score3 &gt;= 60 &amp;&amp; score3 &lt; 80) &#123; System.out.println("成绩：" + score3 + "分，刚好及格、成绩一般般...");&#125; else &#123; System.out.println("成绩：" + score3 + "分，很好很强大...");&#125; 分支结构在Java语言中占有很重的分量，使用分支结构可以控制代码执行顺序： if结构：如果if后面的表达式为true则执行后面的代码，false则不执行，如果if结构中只有一样代码可以省略大括号，不过为了代码可读性一般不推荐； if…else…结构：用自然语言翻译就是如果……否则……，如果满足if条件则执行if分支中代码，否则执行else分支中代码； if…else if…else…结构：此结构中else if可以有多层，比如以上实例用自然语言描述应该是以下这样： 如果分数小于60分，则不及格，反之大于60分可以分为60-80分之间合格，80以上优秀，以此类推就会有多种情况。注意：这种结构中可能发生一种很容易出现的逻辑错误： 1234567891011121314//逻辑错误演示：int score4 = 110;if (score4 &gt; 60)&#123; System.out.println("成绩：" + score4 + "分，刚好及格、成绩一般般...");&#125;else if (score4 &gt; 80)&#123; System.out.println("成绩：" + score4 + "分，很好很强大...");&#125;else if (score4 &gt; 100)&#123; System.out.println("成绩：" + score4 + "分，很明显这是一个bug...");&#125; 看看上例代码，运行发现并没有报错，却只输出了if分支内的语句：“成绩：110分，刚好及格、成绩一般般…”，后面的条件同样满足，却没有输出，而实际上我们希望看到的应该是最后一个else…if分支中的语句，因为，else含义就是否则，它本身就是一个条件，也就是说它要对if条件取反，再去执行取反后的条件和语句。 switch分支语句switch分支结构的格式如下： 12345678910111213141516171819public static void main(String[] args) &#123; String season = "大冷天"; switch (season) &#123; case "春天": System.out.println("春回大地"); break; case "夏天": System.out.println("骄阳似火"); break; case "秋天": System.out.println("秋高气爽"); break; case "冬天": System.out.println("冰天雪地"); break; default: System.out.println("这不是一个季节嘛~~~"); &#125; &#125; 我们先看看执行效果：如果我们给变量season赋值为春天，就会执行打印：春回大地，同样的，给变量赋予其他的季节，也就是case标签后的值，就会执行对应的操作，如果赋值不是任何一个case后的值，则会执行default后的语句块。需要注意的是： switch后面表达式的类型只能是：byte，char、short、int四种证书类型或者枚举和String类型，不能和if一样使用boolean类型； case标签之后会紧跟代码块，case作为代码块的唯一标识； 每一个case块后都有一条break;语句作为控制，如果注释掉某个break并不会发生编译错误，但是代码会顺序往下执行直到碰到下一个break； switch的用法比较好掌握，且在笔者所经历的项目中并没有太多的应用，这一部分权当备忘，万一用到再回头查看。 本节代码路径]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter3 流程控制</category>
      </categories>
      <tags>
        <tag>分支结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter3.1 流程控制]]></title>
    <url>%2F2018%2F12%2F08%2FJavaSE%2FChapter3%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F1%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[ava编程语言中提供了三种流程控制结构：分别是顺序结构、分支结构和循环结构…… 1、流程控制Java编程语言中提供了三种流程控制结构：分别是顺序结构、分支结构和循环结构： 顺序结构：程序自上而下逐行执行，排在前面的代码先执行，后面的代码后执行； 分支结构：根据条件选择性执行某段代码，使用if…else…或switch结构； 循环结构：根据循环条件重复执行某段代码，使用for、while和foreach循环结构。]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter3 流程控制</category>
      </categories>
      <tags>
        <tag>流程控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter2.3 运算符]]></title>
    <url>%2F2018%2F12%2F07%2FJavaSE%2FChapter2%20%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F3%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[一般来说项目上主要使用直接赋值、算数、逻辑和比较运算符这几类，运算并赋值在笔者所在团队是不可使用的，因为可读性相对差，位运算的话在笔者经历的项目中也是比较少用的…… 3、运算符Java语言中运算符分为以下几种： 一般来说项目上主要使用直接赋值、算数、逻辑和比较运算符这几类，运算并赋值在笔者所在团队是不可使用的，因为可读性相对差，位运算的话在笔者经历的项目中也是比较少用的，知道大概的意思就可以，细节可以在用到的时候再查询。 ####算数运算符：+、-、*、/、%、++、– 12345678910111213141516public static void main(String[] args) &#123; double d1 = 6.4; int d2 = 2; int d3 = 0; System.out.println("d1 + d2 = " + (d1 + d2)); System.out.println("d1 - d2 = " + (d1 - d2)); System.out.println("d1 * d2 = " + (d1 * d2)); System.out.println("d1 / d2 = " + (d1 / d2)); System.out.println("d1 / d3 = " + (d1 / d3)); //结果输出：d1 / d3 = Infinity // System.out.println("d2 / d3 = " + (d2 / d3)); //结果异常 System.out.println("d1 % d2 = " + (d1 % d2)); // System.out.println("d2 % d3 = " + (d2 % d3)); //结果异常 &#125; 输出的结果是： 上面实例中实现了自动类型转换后的算数运算，值得注意的是除法运算和取余运算： 在除法运算，如果两个操作数都是整数，输出结果也是整数且除数不能为0，否则输出异常，如果有一个浮点数或者两个浮点数，除数为0时输出结果为：无穷大。 取余运算中，取到的余数不一定是整数，取余也是要用到除法运算，所以遵循除法运算的规则，不过在有一个浮点数或者两个浮点数的运算中，如果第二个操作数是0，那么输出结果是非数：NaN。 ++、–和前置后置： 123456789101112public static void main(String[] args) &#123; int i = 5; System.out.println(i++); System.out.println(i); int j = 6; System.out.println(++j); System.out.println(j); int a = 4; System.out.println(a++ + 3 + a-- + ++a - 1); //4 + 3 + 5 + 5 - 1&#125; 以上实例输出结果分别为：5、6、7、7、16； 后置：当++或者–后置时，先对操作数取值，再进行运算； 前置：当++或者–前置时，先进行运算，再取运算后的操作数的值； –自减：用法和++基本一致，不过是操作数减1； 上面实例最后一个输出解析：a++ +3，先进性运算得到7，此时a=5，7+5得到12，此时a = 4，然后12 + ++a计算时，先运算++a，此时a=5，12+5=17，再减1得到结果16； 赋值运算：=赋值运算符用于为变量赋值，除了前面的例子中看到的直接赋值，还可以将变量或者表达式赋值给另一个变量，参看本节图1，此处不再叙述。 逻辑运算符和比较运算符： &amp;&amp;和&amp;：与的运算，前者短路，后者不短路，也就是说，使用前后两个表达式运算时同时为true则返回true，有一个false则返回false，但是&amp;&amp;判断如果第一个表达式返回false，则不进行后面表达式运算，直接返回false，&amp;要判断所有的表达式，使用&amp;&amp;效率更高； ||和|：或的运算，前后表达式只要有一个true，则整体返回true，否则返回false，同样的，||运算只要判断有一个表达式返回true则结束运算直接返回true，|要对所有表达式运算才会返回，||效率更高； ！：非，操作数取反； ^：异或，两个操作数不同则返回true，否则返回false； 实例如下： 123456789public static void main(String[] args) &#123; System.out.println(6 &gt; 4 &amp;&amp; 3 &gt; 5); //false System.out.println(6 &gt; 4 &amp; 3 &gt;= 5); //false System.out.println(6 &gt; 4 || 3 &gt; 5); //true System.out.println(6 &gt; 4 | 3 &gt; 5); //true System.out.println(!(6 &gt; 4)); //false System.out.println(6 &gt; 4 ^ 5 &gt; 3); //false System.out.println(4 == 5); //false&#125; 三元运算符：三元运算符也叫三目运算符，用法很简单，实例如下： 1System.out.println(5 &gt;=3 ? "你是对的":"你又错了"); 结果输出：你是对的，解析一下，先对前面的逻辑表达式运算得到true的结果，则返回第一个操作数的值，如果表达式是false，则返回第二个操作数的值 位运算符：位操作都是基于二进制来说的，我们平时使用都是十进制，二进制的基本法则是逢二进一，我们有一个方法可以把十进制整数转换为二进制字符串，也可以用Integer.parseInt()方法实现二进制到十进制的转换，如下： 1234//输出：10的二进制表达式是：1010System.out.println("10的二进制表达式是：" + Integer.toBinaryString(10));//输出：1010的十进制表达式是：1010System.out.println("1010的十进制表达式是：" + Integer.parseInt("1010", 2)); 输出结果是1010和10，基于以上方法我们看一下位运算： 按位或|：对每一位进行或运算： 12345int m = 6;int n = 7;System.out.println(m + "的二进制表达式是：" + Integer.toBinaryString(m)); //输出110System.out.println(n + "的二进制表达式是：" + Integer.toBinaryString(n)); //输出111System.out.println(m | n); //输出结果为7，或运算后得到二进制111，转换十进制得到7 按位与&amp;：对每一位进行与运算： 1System.out.println(m | n); //输出结果为6，与运算后得到二进制110，转换十进制得到6 异或^： 任何数和自己异或都是0； 任何数和0异或都等于自己； 123System.out.println(m ^ n); //输出结果为1，或运算后得到二进制001，转换十进制得到1System.out.println("和自己异或：" + (m ^ m)); //输出0System.out.println("和0异或：" + (m ^ 0)); //输出本身 按位非~： m=6，6的二进制是：00000110，取非得到：11111001，换算成二进制得到：-7，这一部分运算涉及到二进制原码，反码和补码，可以再深入了解。 1System.out.println(~m); //输出-7 左移和右移&lt;&lt;、&gt;&gt;： 左移：根据一个数的二进制，将每一位向左移动，最右一位补0； 右移：根据一个数的二进制，将每一位向右移动。 123456//6的二进制是110System.out.println(Integer.toBinaryString(m));//6向左移1位后，变成1100，对应的十进制是12System.out.println(m&lt;&lt;1);//6向右移1位后，变成11，对应的十进制是3System.out.println(m&gt;&gt;1); 本节代码路径]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter2 变量和数据类型</category>
      </categories>
      <tags>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter2.2 基本数据类型]]></title>
    <url>%2F2018%2F12%2F06%2FJavaSE%2FChapter2%20%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F2%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java的基本数据类型可以划分为四类八种…… 2、基本数据类型一、分类Java的基本数据类型可以划分为四类八种，如下： 整形： 用于存放整数，赋值超出范围会产生编译错误，例如： 123456789101112public class DataTest &#123; public static void main(String[] args) &#123; byte b = 100; short s = 200; int i = 300; long l = 400; System.out.println("b = " + b + "\n" +"s = " + s + "\n" + "i = " + i + "\n" + "l = " + l); //超出范围，产生编译错误 //byte b1 = 300; &#125;&#125; 上面代码输出结果为： 如果给byte型赋值300，则会产生编译错误，说明每一个数据类型的取值都是有范围的。 字符类型： char型用于存入一个字符，用单引号表示，超过一个字符就会产生编译错误，例如： 12345678910public class DataTest &#123; public static void main(String[] args) &#123; //字符型 char c1 = 'A'; char c2 = 'AB'; //编译错误 char c3 = '字'; char c4 = '字符';//编译错误 &#125;&#125; 浮点型： Java浮点数有两种，double代表双精度64位，float代表单精度32位，Java语言的浮点类型默认double类型，如果希望把一个浮点数当成float类型处理，要加F或f，例如： 12float f = 3.14F;double d = 3.14; 布尔型： 布尔型只有一种boolean类型，用于表示逻辑上的”真”或”假”，对应true / false，例如： 12boolean b1 = false;boolean b2 = true; boolean主要用于做为旗标进行流程控制，一般使用场景有： if条件语句； while循环控制语句； do while循环控制语句； for循环控制语句 三目运算符等 二、基本类型之类型转换： 1、基本类型转换 Java8种基本类型之间，除去boolean之外的7种，大部分相互之间可以转换，又分为两种转换方式：自动类型转换和强制类型转换。 自动类型转换： 如本节图一所示，当把一个取值范围小的数值或变量直接赋值给另一个取值范围大的变量时，就会发生强制类型转换；反之则需要强制类型转换，例如： 1234567891011121314151617181920212223242526272829public class DataChangeTest &#123; public static void main(String[] args) &#123; byte b = 100; int i = b; System.out.println("b = " + b); long l = 1000L; float f1 = l; System.out.println("f1 = " + f1); float f = 3.14F; double d = f; System.out.println("d = " + d); char c = 'A'; int i1 = c; System.out.println("i1 = " + i1); byte b1 = 65; //byte类型不能自动转换为char类型 //char c1 = b1; char c1 = 'B'; //以下代码将编译报错，char型不能自动转换为byte型 //byte b2 = c1; //short s = c1; &#125;&#125; 自动类型转换图： 2、强制类型转换 如果我们需要反向转换，也就是将上图箭头右边的类型转换为左边的类型，就需要强制类型转换了，转换的语法是：（转换类型）值，例如： 123int i2 = 130;byte b2 = (byte)i2;System.out.println(b2); 上面这个实例输出的结果是：-126；想象一下有一大一小两个瓶子，如果大瓶子水不多将其倒入小瓶子的话还好，如果水很多，就会发生溢出现象，从而造成数据损失，上例就是典型的溢出。 3、表达式类型的自动提升 当一个表达式中包含多种基本数据类型的时候，表达式中的数据类型将会自动提升到与表达式中最高等级操作数相同的类型，例如： 1234short s = 10;int i3 = 100;i3 = i3 + s;System.out.println("i3 = " + i3); 输出结果为：110，表达式中自动将short提升为int型，进行了加法运算； 注意：+ 的存在如果是在基本数据类型的话就是加法运算符，如果是有字符串和基本数据类型存在，则可能作为字符串连接符，例如： 12System.out.println("hello" + 'A' + 3); System.out.println(7 + 'A' + "hello"); 上面例子分别输出：helloA3和72hello，为什么会这样呢？ 第一个表达式先进行字符串连接将A转换为字符串拼接，接着对helloA+3运算，将3转换为字符串，得到：helloA3； 第二个表达式先进行7+A运算，将A提升为int型，转换成A对应的ASCII值：65，相加得到72，与字符串hello运算将72提升为字符串，然后进行连接，得到结果：72hello； 本节代码路径]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter2 变量和数据类型</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter2.1 变量]]></title>
    <url>%2F2018%2F12%2F05%2FJavaSE%2FChapter2%20%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F1%E3%80%81%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Java变量和命名规范，变量的定义：命名一个数据的标示符…… 1、变量变量的定义：命名一个数据的标示符，如： 1int number = 100; int：数据类型，表示一个整数； number：变量，标示符； =：赋值操作符； 100：数据类型的值； 变量分类： 全局变量：也叫实例变量，独立于方法之外的变量，一个类中有且只有一个相同的变量名 局部变量：类方法中定义的变量，可以在多个方法中定义相同变量名； 类变量：独立于方法之外，用static修饰的变量，可以用类名直接调用，一个类中有且只有一个变量名 例如： 1234567891011121314public class Variable &#123; //类变量 static int i1 = 0; //全局变量 int i2 = 1; public void method() &#123; //局部变量 int i3 = 2; &#125;&#125; 变量定义规范： 变量命名遵循的原则是：单个单词全部小写，多个单词组成的话，第一个单词首字母小写，其余单词首字母大写。最重要的一点是，所有变量命名一定有其意义，尽量避免无意义命名。 本节代码路径]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter2 变量和数据类型</category>
      </categories>
      <tags>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter1.3 第一个Java程序]]></title>
    <url>%2F2018%2F12%2F04%2FJavaSE%2FChapter1%20%E6%A6%82%E8%BF%B0%2F3%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[开发第一个Java程序：HelloWorld…… 3、第一个Java程序编辑Java源代码在任意文件夹下新建一个文本文件，并在文件中输入以下代码： 1234567public class HelloWorld&#123; public static void main(String[] args) &#123; System.out.println("HelloWorld"); &#125;&#125; 将上面文本文件保存为HelloWorld.java（扩展名从.txt变为.java），此文件就是Java程序源文件。 编译Java程序在HelloWorld.java文件所在文件夹下打开CMD，我所知道的有这样几种方法： Win+R快捷键：输入：CMD打开，输入：D:切换到D盘，输入：cd /代码路径/找到指定文件夹，用过Linux都知道Windows的命令行用起来多纠结； 直接找到源码位置，在地址栏输入：cmd然后Enter打开，如图； 找到源码位置，按住shift右击鼠标，找到cmd打开； 在cmd窗口输入：javac HelloWorld.java编译源码，生成一个HelloWorld.class字节码文件，如图： 运行Java程序继续在cmd输入：java HelloWorld，界面输出：HelloWorld则运行成功，如图： 如果出现无法加载主类的提示，建议参看Java开发环境搭建检查环境变量是否正确配置。 Java源文件命名规则我们的文件自然不是随意命名的，简单规则如下： Java源文件后缀一定是.java（建议设置显示文件扩展名），如图： 一般来说，Java源文件名是任意的，不过，如果源码定义了public类，那么主文件名必须与public类相同，不信？我们把代码里面public修饰的HelloWorld去掉一个d，javac编译走一个； 一般我们使用首字母大写的驼峰式命名法，关于命名规范，后面还会详细说道。 Java严格区分大小写 注意的问题环境变量一定一定要仔细设置，就这一个小小的HelloWorld，动手操作时真的不一定一帆风顺哦！！！]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter1 Java概述</category>
      </categories>
      <tags>
        <tag>HelloWorld</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter1.2 Java开发环境搭建]]></title>
    <url>%2F2018%2F12%2F03%2FJavaSE%2FChapter1%20%E6%A6%82%E8%BF%B0%2F2%E3%80%81Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Java开发环境搭建，包含Windows和Linux…… 2、Java开发环境搭建下载安装JDK [Oracle官网下载JDK链接][http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html] 下载完成后运行安装JDK，个人喜欢安装在D盘下； JDK安装目录结构： bin：存放工具命令，如javac，java等命令； db：安装JavaDB路径； include：平台特定的头文件； jre：运行Java程序所必须的JRE环境； lib：相关的Jar依赖包； 配置环境变量（Win10为例）： 依次打开：控制面板——系统和安全——系统——高级系统设置——环境变量——系统变量； 新建，变量名：JAVA_HOME，变量值：D:\Program Files\Java\jdk1.8.0_131 找到Path，添加：%JAVA_HOME%\bin（注意分号） 新建，变量名：classpath，变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\toos.jar;（前面加.表示当前路径，用以强制Java解释器在当前路径下搜索Java类，用；分隔变量） 如图： 注意，配置了classpath，java命令才能被识别到，这个地方很容易出错，请一定注意。 验证安装： 快捷键Win+R打开运行——CMD，输入Java运行命令，javac编译命令或Java -version，如下图显示就是安装成功，So easy！！！ ​ 搭建好了环境，我们来跑一个小小的程序，也就是每一个程序员都知道的：HelloWorld 附1：Linux环境安装JDK： 下载对应版本的JDK，通常是tar.gz后缀文件； 通过xftp客户端上传至Linux环境/usr目录下； 12345cd /usr mkdir javacp jdk-8u161-linux-i586.tar.gz java/cd java tar -xzvf jdk-8u161-linux-i586.tar.gz 1 配置环境变量： 1234567vim /etc/bashrc#文件末尾添加export JAVA_HOME=/usr/java/jdk1.8.0_161export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib:$CLASSPATHexport JAVA_PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;JRE_HOME&#125;/binexport PATH=$&#123;JAVA_PATH&#125;:$PATH 执行命令使配置生效：/etc/bashrc```123456. 输入```java -version```命令查看java版本发现报错： ```shell -bash: /usr/java/jdk1.8.0_161/bin/java: /lib/ld-linux.so.2: bad ELF interpreter: No such file or directory 出现该问题是因为JDK和系统版本不匹配的问题。 执行命令：install glibc.i686```解决版本问题，输入```java -version```发现已正确安装：12345```shelljava version &quot;1.8.0_161&quot;Java(TM) SE Runtime Environment (build 1.8.0_161-b12)Java HotSpot(TM) Client VM (build 25.161-b12, mixed mode) ​]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter1 Java概述</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter1.1 Java语言概述]]></title>
    <url>%2F2018%2F12%2F02%2FJavaSE%2FChapter1%20%E6%A6%82%E8%BF%B0%2F1%E3%80%81Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[1990年，Sun公司James Gosling领导的”Green”计划开发新语言——Oak； 1995年，Sun公司正式发布Java语言…… 1、Java语言概述Java大事记 1990年，Sun公司James Gosling领导的”Green”计划开发新语言——Oak； 1994年，第一个Java网页浏览器：WebRunner，Oak改名Java； 1995年，Sun公司正式发布Java语言； 1996年，Sun公司发布JDK1.0，包含JDK（开发环境）和JRE（运行环境）； 1997年，Sun公司发布JDK1.1； 1998年，Sun公司发布JDK1.2，同时发布JSP/Servlet，并将Java分为J2EE、J2SE和J2ME三个版本； J2ME：主要用于控制移动设备等； J2SE：Java技术核心，是其余两种版本的核心； J2EE：企业级应用开发； 2009年，Oracle收购Sun； 2011年，Oracle发布JavaSE7； 2014年，Oracle发布JavaSE8； 2017年，Oracle发布javaSE9； Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。 ——引用自《百度百科》 以上是来自百度百科关于java介绍的一段引用，因为接触C++并不多，对于C++的多继承和指针等也就只限于听说，所以我们只说Java，解释一下这段话：我个人认为，Java语言最重要也是最需要首先掌握的就是四个字：面向对象。 面向过程：区别于面向对象，软件开发领域还有一种开发方式叫做面向过程，这种开发方法按照功能细分系统软件，自顶而下执行，最小的单元是函数，执行时由主函数调用普通函数，普通函数之间依次调用，完成软件功能。软件中所有的模块都细化成一个个函数，这样的程序设计时，需要将客观世界模型分解成一个个功能，与人类思维习惯不一致，而且当需求更改时，可能需要自顶而下修改模块结构，自有其局限性； 面向对象：面向对象的设计方式采用现实世界中客观存在的事物（对象）为中心来思考，根据具体事务的特点，将其抽象为java程序中的最小设计单位——类。在系统构造中也尽可能采用人类自然的思维方式。行为或功能则作为程序中的方法存在，由对象调用。 举例来说： 场景1：A想喝水 面向过程描述：喝（A，水）； 面向对象描述：A 喝（水）； 明显面向对象的描述更符合我们本身的思维习惯 对象：具体说一下对象：拿一台显示器举例，比如我现在用的是一台Dell23寸旋转屏黑色显示器，它可以用来显示代码和文档，你脑海中是不是第一时间会想象到这台显示器大致的样子，我们这样表示一下： 12345678910&#123; 属性： &#123; 品牌：Dell， 尺寸：23寸， 颜色：黑色， 是否能旋转：是 &#125;； 功能：显示&#125; 这样的描述，我们抽象为对象的最小单位，也就是类，一个基本类的组成也就是：属性+方法；在Java语言中，我们也把属性叫做全局变量，用来描述一个对象的属性，功能叫做方法，用来描述一个对象的可以做的事情，这有共同属性和方法的一类事物就构成了Java中最核心的概念——类（）对象的抽象。 面向对象语言的基本特征： 封装：将对象的细节隐藏起来，暴露一些公共的方法来访问，比如显示器显示代码，我们不需要知道怎么显示的细节，只需要调用显示的方法就可以； 继承：继承是面向对象编程语言中很重要的一个概念，主要用于实现代码的复用，通过一个类继承另一个类，获得父类的属性和方法； 多态：从继承而来，简单来说就是父类的引用指向子类的对象，运行时依旧表现子类的行为特征，也就是说同一个类型的对象执行同一个方法的时候，可能表现出多种行为特征； 除此之外，抽象也是一个重要的特征，抽象是说我们只需要关注与当前主题有关的方面而忽略无关的方面，比如显示器来说，我们以上所说的属性不过是一部分，还有很多可以描述的属性，但是不一定需要，我们只关心和系统有关的部分。]]></content>
      <categories>
        <category>java</category>
        <category>JavaSE阶段知识</category>
        <category>Chapter1 Java概述</category>
      </categories>
      <tags>
        <tag>简介</tag>
      </tags>
  </entry>
</search>
